% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nano_scoring.R
\name{nano_scoring}
\alias{nano_scoring}
\title{Score data from fitted model and compare with response by percentiles}
\usage{
nano_scoring(
  nano,
  data = NA,
  model_no = NA,
  percentiles,
  train_test = "data_id",
  save = TRUE
)
}
\arguments{
\item{nano}{a nano object containing the fitted models.}

\item{data}{a list of datasets. If the underlying dataset is the same for each model, can
only input a list with a single element.}

\item{model_no}{the positions of each model in the list of models in the nano object for which
the PDP should be calculated. If not entered, the last model is taken by default.}

\item{train_test}{a character. Variable in \code{data} which contains split for training,
testing and holdout datasets (optional). Can only have the values: "train", "test",
"holdout".}

\item{save}{a logical specifying whether the .}
}
\value{
if \code{save = TRUE} then returns nano object with the specified models scored. If
\code{save = FALSE} then returns a list with the specified models scored.
}
\description{
Predict on data from fitted model and compares the mean prediction with the
mean response by the inputted percentiles.
}
\details{
Functions checks whether the data contains the \code{train_test} column. If it does then
scoring is done for each split specified in the \code{train-test} column. Otherwise, the scoring
is done on the total data.
If desire to perform scoring on a subset of the data (e.g. to see performance of the model on
a specific part of the data) then the \code{data} argument can be used to supply the data subseted
in the desired manner. If the \code{data} argument is not used, then by default the data used to
train the model is used by the function.
}
\examples{
\dontrun{
if(interactive()){
 library(h2o)
 library(nano)
 
 h2o.init()
 
 # import dataset
 data(property_prices)
 train <- as.h2o(property_prices)
 
 # set the response and predictors
 response <- "sale_price"
 var <- setdiff(colnames(property_prices), response)
 
 # build grids
 grid_1 <- h2o.grid(x               = var,
                    y               = response,
                    training_frame  = train,
                    algorithm       = "randomForest",
                    hyper_params    = list(ntrees = 1:2),
                    nfolds          = 3,
                    seed            = 628)

 grid_2 <- h2o.grid(x               = var,
                    y               = response,
                    training_frame  = train,
                    algorithm       = "randomForest",
                    hyper_params    = list(ntrees = 3:4),
                    nfolds          = 3,
                    seed            = 628)

 
 obj <- create_nano(grid = list(grid_1, grid_2),
                    data = list(property_prices), # since underlying dataset is the same 
                    ) # since model is not entered, will take best model from grids
 
 # score on both models
 obj <- nano_scoring(nano = obj, model_no = 1:2, percentiles = seq(0, 1, 0.02), save = TRUE)
 }
}
}
